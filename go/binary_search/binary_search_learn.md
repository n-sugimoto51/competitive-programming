## 既に知っていること

- ソート済みのデータを探索する場合に利用

## 概要

- ソート済み配列の中から目的のものを高速に探索する

## メリット

- n 個の要素からなるソート済み配列から目的の値を探索する場合
  - 二分探索を行えば計算量は $ O(\log n) $
  - 線形探索は $ O(n) $

## デメリット

- ソート済み配列出なければ使えない

## 使い所

## 実際にコードを書いてわかったこと

- left, right, mid を利用してデータを二分する
- mid を計算するときは`(left+right)/2`

## Go で二分探索

### 既存の`sort.Search()`を利用する

### 自分で書いてみる

## まとめ

## 新たに知ったこと

## 参考

- [めぐる式二分探索法のすすめ](https://qiita.com/drken/items/97e37dd6143e33a64c8c)
- [Go 代表的なアルゴリズム](https://zenn.dev/satumahayato010/articles/58fb473c40d9af)
- [Go sort.Search](https://pkg.go.dev/sort#Search)

## ChatGPT

### Go Binary Search の解説

二分探索（Binary Search）は、ソートされたデータ（例えば、配列やスライス）から特定の値を効率的に見つける手法です。このアルゴリズムは、値が並び順に従って配置されたデータ構造で効果的に使われます。

具体的な Go 言語の関数 `Search` は、次のような動作をします：

```go
func Search(n int, f func(int) bool) int
```

- `Search` 関数は、0 から n-1 までの範囲内の整数 i に対して、与えられた関数 `f` を呼び出します。
- `f(i)` が true となる最初の i の値を見つけ、そのインデックスを返します。
- `f(i)` が true となるインデックスが見つからない場合は、n（引数の上限値）を返します。

このように、二分探索では指定された条件（`f` の戻り値が true）を満たす最初の要素を効率的に探します。
例えば、以下のコードでは、ソートされた整数のスライス `data` から特定の値 `x` を探しています。

```go
x := 23
i := sort.Search(len(data), func(i int) bool { return data[i] >= x })

if i < len(data) && data[i] == x {
	// xがdata[i]に存在する場合の処理
} else {
	// xがdataに存在しない場合、iはxが挿入されるべきインデックスになります
}
```

上記の例では、スライス `data` が昇順にソートされている場合、`Search` 関数を使って`data[i] >= 23` を満たす最初のインデックス `i` を見つけます。
もし `i` がスライスの範囲内であり、`data[i]` が `x` と一致する場合、`x` がスライス `data` に存在することが分かります。
一致しない場合は、`x` がスライス `data` に存在しないことが分かりますが、`i` の値を利用して `x` がスライスに挿入されるべき位置を求めることができます。

このように、二分探索はデータのソートと探索を効率的に行う手法であり、大きなデータセットにおいて高速に値を見つけるのに役立ちます。
